[
  {
    "objectID": "mcu.html",
    "href": "mcu.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "Within the system the MCU is responsible for converting the tuning words sent from the FPGA into real time audio output using direct digital synthesis (DDS) and the digital to analog converter. To run this pipeline reliably, the MCU runs three coordinated blocks of logic: the main execution loop, an external interrupt handler that responds to FPGA signals and a timer interrupt that drives the audio sampling rate. These three subsystems within the MCU interface to ensure new tuning data is captured as soon as it becomes available such that the DAC outputs smooth and continuous sine waves at the correct frequency. This system is described by the following diagram.\n\n\n\nFigure 1: MCU System Overview\n\n\n\n\nThe main loop begins by configuring the system clock, GPIO pins, external interrupts, the SPI interface, the DAC, and the timers required for DDS. After initialization, the MCU waits for an interrupt on PA6, which the FPGA asserts whenever a fresh set of tuning data is ready. When that interrupt occurs, the MCU performs four SPI transactions to retrieve the full tuning word from the FPGA.\nOnce the MCU reconstructs the 32-bit tuning word from four 8-bit packages it shifts the values into the appropriate range and maps to the 200-2000 Hz output frequency span. The mapped frequency then computes the corresponding phase increment value used by the DDS phase accumulator. The phase increment is calculated once per tuning-word update and is stored in a global variable for real-time interrupt use. This value determines how quickly the MCU will step through the sine LUT and therefore sets the output tone‚Äôs frequency. If the trigger signal on PA8 is detected as active, the MCU initiates a short debounce-and-hold period to ensure the system doesn‚Äôt retrigger unintentionally.\n\n\n\nThe EXTI9_5 interrupt is shared by PA6 ‚Äúdone‚Äù signal from the FPGA and PA8 ‚Äútrigger‚Äù signal. The MCU branches depending on which pin is fired. For PA6, the FPGA ready signal, the interrupt handler clears the interrupt flag and notifies the main loop that the SPI transfer can begin. If PA8 fires, on a clean falling edge from the scanner trigger input, the handler clears the interrupt and checks whether a debounce sequence has been activated. If not, it begins debouncing to prevent false activations caused by noisy mechanical switch transitions. Both interrupt paths immediately return to the main loop ensuring the system remains responsive. In essence the EXTI9_t Interrupt handler serves as an event detector triggering time consuming tasks in the main loop.\n\n\n\nThe TIM7 interrupt runs at a constant 96 kHz frequency to drive the DDS. When this interrupt fires upon overflow, the MCU clears the interrupt flag checking whether the audio output should be enabled based on the scanner trigger state. If audio is disabled the interrupt outputs a constant mid-scale value (2048), updating the DAC accordingly and resulting in silence. If audio is enabled then the DDS phase accumulator increments by the phase increment already determined in the main loop. The upper bits of the accumulator index through the 256-entry sine LUT. The next eight bits form a fractional value used for linear interpolation between adjacent LUT entries, producing a smooth, high-quality sine wave even when the LUT would otherwise be undersampled at higher frequencies. After interpolation, the resulting sample is recentered around mid-scale (2048) and written to the DAC, generating the analog audio output. This interrupt-driven DDS process allows the MCU to generate stable, real-time audio that responds directly to updates from the FPGA.\n\n\n\nA MATLAB script was written to generate a reliable 256-element sine look up table (LUT). The script first creates the LUT by generating entries at 256 equally-spaced angles from 0 to 2ùúã. It then calculates the sine of each angle producing values between -1 and +1, these values must be shifted and scaled to ensure such that they are all positive and fall between 0 and 1 since the DAC is unipolar. These values are normalized to the maximum 12-bit DAC value to minimize clipping, overflow, and undesired mapping behavior when the DAC outputs the LUT values. These values are converted to integers to optimize performance and reduce the likelihood of timing errors.\nTo visualize the LUT and visualize how the produced sine wave would look at 200 Hz and 2,000 Hz, a second MATLAB script was employed. The visualization confirmed that the LUT sine wave was very close to an ideal sine wave output, as desired. The visualization also demonstrates that as frequency increases, sine smoothness decreases; however the 2000 Hz wave was seen as acceptable for our system and the LUT was then ready to be included in our MCU process.\n\n\n\nFigure 2: LUT Visualization with MATLAB"
  },
  {
    "objectID": "mcu.html#mcu-design",
    "href": "mcu.html#mcu-design",
    "title": "Barcode Beats",
    "section": "",
    "text": "Within the system the MCU is responsible for converting the tuning words sent from the FPGA into real time audio output using direct digital synthesis (DDS) and the digital to analog converter. To run this pipeline reliably, the MCU runs three coordinated blocks of logic: the main execution loop, an external interrupt handler that responds to FPGA signals and a timer interrupt that drives the audio sampling rate. These three subsystems within the MCU interface to ensure new tuning data is captured as soon as it becomes available such that the DAC outputs smooth and continuous sine waves at the correct frequency. This system is described by the following diagram.\n\n\n\nFigure 1: MCU System Overview\n\n\n\n\nThe main loop begins by configuring the system clock, GPIO pins, external interrupts, the SPI interface, the DAC, and the timers required for DDS. After initialization, the MCU waits for an interrupt on PA6, which the FPGA asserts whenever a fresh set of tuning data is ready. When that interrupt occurs, the MCU performs four SPI transactions to retrieve the full tuning word from the FPGA.\nOnce the MCU reconstructs the 32-bit tuning word from four 8-bit packages it shifts the values into the appropriate range and maps to the 200-2000 Hz output frequency span. The mapped frequency then computes the corresponding phase increment value used by the DDS phase accumulator. The phase increment is calculated once per tuning-word update and is stored in a global variable for real-time interrupt use. This value determines how quickly the MCU will step through the sine LUT and therefore sets the output tone‚Äôs frequency. If the trigger signal on PA8 is detected as active, the MCU initiates a short debounce-and-hold period to ensure the system doesn‚Äôt retrigger unintentionally.\n\n\n\nThe EXTI9_5 interrupt is shared by PA6 ‚Äúdone‚Äù signal from the FPGA and PA8 ‚Äútrigger‚Äù signal. The MCU branches depending on which pin is fired. For PA6, the FPGA ready signal, the interrupt handler clears the interrupt flag and notifies the main loop that the SPI transfer can begin. If PA8 fires, on a clean falling edge from the scanner trigger input, the handler clears the interrupt and checks whether a debounce sequence has been activated. If not, it begins debouncing to prevent false activations caused by noisy mechanical switch transitions. Both interrupt paths immediately return to the main loop ensuring the system remains responsive. In essence the EXTI9_t Interrupt handler serves as an event detector triggering time consuming tasks in the main loop.\n\n\n\nThe TIM7 interrupt runs at a constant 96 kHz frequency to drive the DDS. When this interrupt fires upon overflow, the MCU clears the interrupt flag checking whether the audio output should be enabled based on the scanner trigger state. If audio is disabled the interrupt outputs a constant mid-scale value (2048), updating the DAC accordingly and resulting in silence. If audio is enabled then the DDS phase accumulator increments by the phase increment already determined in the main loop. The upper bits of the accumulator index through the 256-entry sine LUT. The next eight bits form a fractional value used for linear interpolation between adjacent LUT entries, producing a smooth, high-quality sine wave even when the LUT would otherwise be undersampled at higher frequencies. After interpolation, the resulting sample is recentered around mid-scale (2048) and written to the DAC, generating the analog audio output. This interrupt-driven DDS process allows the MCU to generate stable, real-time audio that responds directly to updates from the FPGA.\n\n\n\nA MATLAB script was written to generate a reliable 256-element sine look up table (LUT). The script first creates the LUT by generating entries at 256 equally-spaced angles from 0 to 2ùúã. It then calculates the sine of each angle producing values between -1 and +1, these values must be shifted and scaled to ensure such that they are all positive and fall between 0 and 1 since the DAC is unipolar. These values are normalized to the maximum 12-bit DAC value to minimize clipping, overflow, and undesired mapping behavior when the DAC outputs the LUT values. These values are converted to integers to optimize performance and reduce the likelihood of timing errors.\nTo visualize the LUT and visualize how the produced sine wave would look at 200 Hz and 2,000 Hz, a second MATLAB script was employed. The visualization confirmed that the LUT sine wave was very close to an ideal sine wave output, as desired. The visualization also demonstrates that as frequency increases, sine smoothness decreases; however the 2000 Hz wave was seen as acceptable for our system and the LUT was then ready to be included in our MCU process.\n\n\n\nFigure 2: LUT Visualization with MATLAB"
  },
  {
    "objectID": "more.html",
    "href": "more.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "This project would not have been successful without the tireless efforts of the following individuals:\nProf.¬†Spencer - Thank you for providing us with the tools, guidance, and support that propelled us through the semester and made this project possible. This class was truly impactful and we feel grateful for the mentorship and rigorous learning opportunities he stewarded.\nXavier Walter - Thank you for being an incredible support system and mentor to all the engineers. During this course you have worked overtime to help us debug, work through the challenging problems, and provided a calming presence in times of stress. Thank you for printing the barcode poster and consulting on the design of this system.\nMicroPs Tutors - Neil Chulani, Kavi Dey, Troy Kauffman, and Vikram Krishna: thank you for using your previous experiences in MicroPs to guide us through our work and providing a voice of reason. We are very grateful that you took time out of your busy schedules to extend office hours and provide further assistance during the project phase.\nOur classmates - Thank you for supporting us throughout the entire semester, keeping us company during late night work sessions, and making MicroPs a truly memorable experience."
  },
  {
    "objectID": "more.html#acknowledgements",
    "href": "more.html#acknowledgements",
    "title": "Barcode Beats",
    "section": "",
    "text": "This project would not have been successful without the tireless efforts of the following individuals:\nProf.¬†Spencer - Thank you for providing us with the tools, guidance, and support that propelled us through the semester and made this project possible. This class was truly impactful and we feel grateful for the mentorship and rigorous learning opportunities he stewarded.\nXavier Walter - Thank you for being an incredible support system and mentor to all the engineers. During this course you have worked overtime to help us debug, work through the challenging problems, and provided a calming presence in times of stress. Thank you for printing the barcode poster and consulting on the design of this system.\nMicroPs Tutors - Neil Chulani, Kavi Dey, Troy Kauffman, and Vikram Krishna: thank you for using your previous experiences in MicroPs to guide us through our work and providing a voice of reason. We are very grateful that you took time out of your busy schedules to extend office hours and provide further assistance during the project phase.\nOur classmates - Thank you for supporting us throughout the entire semester, keeping us company during late night work sessions, and making MicroPs a truly memorable experience."
  },
  {
    "objectID": "more.html#resources",
    "href": "more.html#resources",
    "title": "Barcode Beats",
    "section": "Resources",
    "text": "Resources\nSTM32L432KC Reference Manual\nSTM32L432KC Datasheet\niCE40UP5K Datasheet\nProof of Concept and Project Inspiration Video"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Final Project: Barcode Beats",
    "section": "",
    "text": "Project creators, Leilani and Thomas, posing with their newly-modified barcode scanner instruments. Learn more about the team members here"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "E155 Final Project: Barcode Beats",
    "section": "Abstract",
    "text": "Abstract\nThis project consists of implementing a digital signal processing pipeline on an FPGA and MCU that manipulates a square-wave input from a barcode scanner to output an audible frequency-modulated sine wave in response to scanning a barcode pattern. The generated square wave signal from reading bar patterns was isolated on the scanner through careful deconstruction and PCB probing. This signal was wired out of the scanner and input into the FPGA, synchronized, and sampled at 48 kHz. The FPGA then applied a finite-impulse-response (FIR) low-pass filter to smooth the corners of the square wave followed by 4x decimation to provide downsample the signal, ensure stable SPI transactions, and allow for smooth frequency modulation. The decimated signal produces a 32-bit tuning word that was sent to the MCU through 4 8-bit SPI to drive a direct digital synthesis (DDS) process. The MCU indexes through the sine look up table (LUT) at a rate dependent on the tuning word, interpolates those values, and outputs them on the digital to analog converter (DAC) peripheral."
  },
  {
    "objectID": "index.html#project-motivation",
    "href": "index.html#project-motivation",
    "title": "E155 Final Project: Barcode Beats",
    "section": "Project Motivation",
    "text": "Project Motivation\nThis project took a barcode scanner and repurposed it to create music! When it comes to checking out at stores or inventory keeping, barcode scanners are omnipresent, but a close look at how they work unleashed a deep exploration into digital signal processing and sound generation. This project was born out of a desire to create excitement out of the mundane tools that surround us, stripes and scanners, and capture the beauty of our surroundings by turning them into music. Along the way a deepened understanding of digital signal processing and the challenges of sound generation was found!"
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "The list of all project specifications developed during the proposal phase were met and are listed below:\n1. FPGA correctly interprets the barcode scanner signal, including proper synchronization and sampling.\n2. FPGA and MCU communicate reliably over SPI.\n3. The system generates audio within the 200‚Äì2000 Hz range by FM-modulating a tone on the microcontroller.\n4. Audio playback activates only when the barcode scanner‚Äôs trigger is pressed.\n5. The pitch of the sound changes according to the barcode being scanned.\n6. The MCU employs a new peripheral (the DAC) to drive the audio output.\n7. There is no audible latency between scanning and the start of the note.\n8. The FIR filtering function is applied to each note to smooth the waveform.\n9. Thomas and Leilani wear stripes. ü¶ì\n10. The system reliably detects barcode scans under normal use.\n11. The system recovers gracefully after an interrupted scan without requiring a reset.\n12. No audible clipping, harsh artifacts, or digital noise are present in the output.\n\n\n\nListen to the barcode instrument in action in the video below!\n\n\n\n\nOscilloscope traces demonstrate reliable frequency modulation on all tested barcodes, with frequencies falling within the desired range. The periods of each oscillation are visibly variable, with cursors and built-in frequency measurements confirming proper behavior. The top image shows a recent frequency measurement of 510 Hz and the second image shows a 1 kHz frequency being recorded. The modulation varies based on the distance the scanner is from the sequence and the scanner‚Äôs movement over the pattern. Even if calculated frequencies fall beyond this range, they are capped at 200 Hz or 2 kHz.\n\n\n\nFigure 1: Modulated DAC Waveform at 510 Hz\n\n\n\n\n\nFigure 2: Modulated DAC Waveforms at 1000 Hz\n\n\n\n\n\nThe decimated FIR filter outputs a 32-bit tuning word calculated on the FPGA is sent to the MCU via 4 8-bit SPI transactions at a 2 MHz baud rate. Communication between the two decives is unidirection, with the MCU operating as the driver, receiving tuning word packets over the MISO line, and the FPGA behaving as the pheripheral, receiving unused zeros in return. Given the selected 8-tap filter weights, tuning word values should range between 0 and 506. Figure 3 illustrates the reconstructed tuning word received by the MCU, and Figure 4 showcases the correct data packet communication on the logic analyzer.\n\n\n\nFigure 3: MCU DDS Print Statements\n\n\n\n\n\nFigure 4: One-Way SPI Transaction on Logic Analyzer\n\n\n\n\n\nThe top module waveforms test the full FPGA system function, including the filter core, which consists of signal synchronization and filtering mechanics, and the the SPI communication file (Figure 5). Figure 6 provides more granular resolution to the intricate processes executing in the FPGA implementation\n\n\n\nFigure 5: Top Module Waveforms Full\n\n\n\n\n\nFigure 6: Top Module Waveforms Zoomed In\n\n\n\n\n\nThe filter and decimation mechanics were tested with random input binary inputs representing a sampled square wave. Figure 7 showcases proper filtering performance for an input of a ‚Äúsampled‚Äù input of 11011000. The achieved tuning word output of 253 matches the expected output calculated by hand.\n\n\n\nFigure 7: Decimated FIR Core Waveforms\n\n\n\n\n\nFigure 8 showcases the full breadboarded installation of the system, demonstrating the physical connections between the scanner inputs, the FPGA, the MCU, and the audio amplifier with a gain of 20.\n\n\n\nFigure 8: Physical System Implementation"
  },
  {
    "objectID": "results.html#results",
    "href": "results.html#results",
    "title": "Barcode Beats",
    "section": "",
    "text": "The list of all project specifications developed during the proposal phase were met and are listed below:\n1. FPGA correctly interprets the barcode scanner signal, including proper synchronization and sampling.\n2. FPGA and MCU communicate reliably over SPI.\n3. The system generates audio within the 200‚Äì2000 Hz range by FM-modulating a tone on the microcontroller.\n4. Audio playback activates only when the barcode scanner‚Äôs trigger is pressed.\n5. The pitch of the sound changes according to the barcode being scanned.\n6. The MCU employs a new peripheral (the DAC) to drive the audio output.\n7. There is no audible latency between scanning and the start of the note.\n8. The FIR filtering function is applied to each note to smooth the waveform.\n9. Thomas and Leilani wear stripes. ü¶ì\n10. The system reliably detects barcode scans under normal use.\n11. The system recovers gracefully after an interrupted scan without requiring a reset.\n12. No audible clipping, harsh artifacts, or digital noise are present in the output.\n\n\n\nListen to the barcode instrument in action in the video below!\n\n\n\n\nOscilloscope traces demonstrate reliable frequency modulation on all tested barcodes, with frequencies falling within the desired range. The periods of each oscillation are visibly variable, with cursors and built-in frequency measurements confirming proper behavior. The top image shows a recent frequency measurement of 510 Hz and the second image shows a 1 kHz frequency being recorded. The modulation varies based on the distance the scanner is from the sequence and the scanner‚Äôs movement over the pattern. Even if calculated frequencies fall beyond this range, they are capped at 200 Hz or 2 kHz.\n\n\n\nFigure 1: Modulated DAC Waveform at 510 Hz\n\n\n\n\n\nFigure 2: Modulated DAC Waveforms at 1000 Hz\n\n\n\n\n\nThe decimated FIR filter outputs a 32-bit tuning word calculated on the FPGA is sent to the MCU via 4 8-bit SPI transactions at a 2 MHz baud rate. Communication between the two decives is unidirection, with the MCU operating as the driver, receiving tuning word packets over the MISO line, and the FPGA behaving as the pheripheral, receiving unused zeros in return. Given the selected 8-tap filter weights, tuning word values should range between 0 and 506. Figure 3 illustrates the reconstructed tuning word received by the MCU, and Figure 4 showcases the correct data packet communication on the logic analyzer.\n\n\n\nFigure 3: MCU DDS Print Statements\n\n\n\n\n\nFigure 4: One-Way SPI Transaction on Logic Analyzer\n\n\n\n\n\nThe top module waveforms test the full FPGA system function, including the filter core, which consists of signal synchronization and filtering mechanics, and the the SPI communication file (Figure 5). Figure 6 provides more granular resolution to the intricate processes executing in the FPGA implementation\n\n\n\nFigure 5: Top Module Waveforms Full\n\n\n\n\n\nFigure 6: Top Module Waveforms Zoomed In\n\n\n\n\n\nThe filter and decimation mechanics were tested with random input binary inputs representing a sampled square wave. Figure 7 showcases proper filtering performance for an input of a ‚Äúsampled‚Äù input of 11011000. The achieved tuning word output of 253 matches the expected output calculated by hand.\n\n\n\nFigure 7: Decimated FIR Core Waveforms\n\n\n\n\n\nFigure 8 showcases the full breadboarded installation of the system, demonstrating the physical connections between the scanner inputs, the FPGA, the MCU, and the audio amplifier with a gain of 20.\n\n\n\nFigure 8: Physical System Implementation"
  },
  {
    "objectID": "fpga.html",
    "href": "fpga.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "The FPGA conducts digital signal processing on the input serial square wave generated by the NetumScan 1D Barcode Scanner‚Äôs infrared receiver. Since the The FPGA conducts and eight-tap Finite Impulse Response (FIR) low-pass filter with a decimation factor of four. The FIR filter employs carefully optimized tap coefficients and convolution to smooth out high-frequency jitters and stark frequency shifts by implementing a weighted frequency average. The governing equation for FIR filtering is outlined with the equation below.\n\\[\ny[n] = \\sum_{k=0}^{M-1} h[k]\\,x[n-k]\n\\]\n\n\nThe FPGA implements convolution via a shift register with eight flip-flops. Only eight registers can be accomodated since this is the maximum number of multipliers within the FPGA‚Äôs DSP block. A 24 MHz clock frequency is initiated with the device‚Äôs internal high-speed oscillator (HSOSC) and a counter is used to divide this frequency to a 48 kHz sampling frequency. Upon each rising edge of the of the sampling signal, a new sample of the input wave is taken an propagates through the shift register. At each stage in the shifting process, signals output from each flip-flop are multiplied by designated signed tap coefficients and summed to produce a tuning word. The factor of 4 decimation reduces the sampling rate to 12 kHz, so the tuning word is only updated every four samples. The downsampling provides added fidelity for future SPI communication, controls the speed for which the frequency modulation on the MCU occurs, and enhances overall signal quality.\n\n\n\nFigure 1: Low-pass FIR Design\n\n\nAfter two decimation cycles, the shift register fills with new barcode data and produces a new 32-bit tuning word that is sent to the MCU over 4 8-bit SPI transactions to govern direct digital synthesis (DDS). More information regarding the process can be found in the MCU design description.\n\n\n\nThe tap coefficients were generated using a MATLAB script that swept through potential coefficient options to find the ‚Äúroundest‚Äù combination of coefficients, indicating greater attenuation of higher harmonic frequencies. Refer to Table 1 below that outlines the optimal coefficient weights.\nTable 1: Tap Coefficient Weights\n\n\n\nCoefficient\nWeight\n\n\n\n\na0\n10\n\n\na1\n33\n\n\na2\n85\n\n\na3\n127\n\n\na4\n127\n\n\na5\n85\n\n\na6\n33\n\n\na7\n10\n\n\n\n\n\n\n\n\nTo determine the optimal 8-tap FIR low-pass filter coefficients for smoothing, the raw signal from a uniform barcode pattern was measured on the oscilloscope (Figure 3). The signal demonstrated an approximate 1.2 kHz square wave frequency around which the MATLAB script was optimized. While the signal frequency depends on the speed and height of the scanner as well as the pattern it reads, this value was deemed as a sufficient baseline for modeling purposes.\n\n\n\nFigure 2: Oscilloscope trace of unfiltered barcode output\n\n\nThis script sweeps through a range of potential cut-off frequencies and designs the subsequent 8-tap filter using fir1 (a built-in MATLAB function that designs FIR filters through the window method). The script then converts the coefficients to signed 8-bit integers that are compatible with the FPGA hardware. These coefficients were applied to a simulated 1.2 kHz square wave input and the Total Harmonic Distortion (THD) of the filtered wave form is measured through the amplitude of the fundamental frequency and its odd harmonics. The applied cutoff frequency that produces the lowest THD value is represented by the smoothest possible output given 8 coefficients. Visualization of the optimal tap weights and the corresponding filtering they introduce is demonstrated in Figure 4.\n\n\n\nFigure 3: MATLAB Script Output Plot\n\n\n\n\n\nThe impacts from the 4x decimated sampling frequency were also visualized using the MATLAB script (Figure 4). The first plot shows and example 1 kHz input square wave that the barcode scanner would receive, the second shows the same square wave sampled at the original 48 kHz frequency, and the third plot shows the downsampled 12 kHz wave.\n\n\n\nFigure 4: MATLAB Script Output Plot"
  },
  {
    "objectID": "fpga.html#fpga-design",
    "href": "fpga.html#fpga-design",
    "title": "Barcode Beats",
    "section": "",
    "text": "The FPGA conducts digital signal processing on the input serial square wave generated by the NetumScan 1D Barcode Scanner‚Äôs infrared receiver. Since the The FPGA conducts and eight-tap Finite Impulse Response (FIR) low-pass filter with a decimation factor of four. The FIR filter employs carefully optimized tap coefficients and convolution to smooth out high-frequency jitters and stark frequency shifts by implementing a weighted frequency average. The governing equation for FIR filtering is outlined with the equation below.\n\\[\ny[n] = \\sum_{k=0}^{M-1} h[k]\\,x[n-k]\n\\]\n\n\nThe FPGA implements convolution via a shift register with eight flip-flops. Only eight registers can be accomodated since this is the maximum number of multipliers within the FPGA‚Äôs DSP block. A 24 MHz clock frequency is initiated with the device‚Äôs internal high-speed oscillator (HSOSC) and a counter is used to divide this frequency to a 48 kHz sampling frequency. Upon each rising edge of the of the sampling signal, a new sample of the input wave is taken an propagates through the shift register. At each stage in the shifting process, signals output from each flip-flop are multiplied by designated signed tap coefficients and summed to produce a tuning word. The factor of 4 decimation reduces the sampling rate to 12 kHz, so the tuning word is only updated every four samples. The downsampling provides added fidelity for future SPI communication, controls the speed for which the frequency modulation on the MCU occurs, and enhances overall signal quality.\n\n\n\nFigure 1: Low-pass FIR Design\n\n\nAfter two decimation cycles, the shift register fills with new barcode data and produces a new 32-bit tuning word that is sent to the MCU over 4 8-bit SPI transactions to govern direct digital synthesis (DDS). More information regarding the process can be found in the MCU design description.\n\n\n\nThe tap coefficients were generated using a MATLAB script that swept through potential coefficient options to find the ‚Äúroundest‚Äù combination of coefficients, indicating greater attenuation of higher harmonic frequencies. Refer to Table 1 below that outlines the optimal coefficient weights.\nTable 1: Tap Coefficient Weights\n\n\n\nCoefficient\nWeight\n\n\n\n\na0\n10\n\n\na1\n33\n\n\na2\n85\n\n\na3\n127\n\n\na4\n127\n\n\na5\n85\n\n\na6\n33\n\n\na7\n10\n\n\n\n\n\n\n\n\nTo determine the optimal 8-tap FIR low-pass filter coefficients for smoothing, the raw signal from a uniform barcode pattern was measured on the oscilloscope (Figure 3). The signal demonstrated an approximate 1.2 kHz square wave frequency around which the MATLAB script was optimized. While the signal frequency depends on the speed and height of the scanner as well as the pattern it reads, this value was deemed as a sufficient baseline for modeling purposes.\n\n\n\nFigure 2: Oscilloscope trace of unfiltered barcode output\n\n\nThis script sweeps through a range of potential cut-off frequencies and designs the subsequent 8-tap filter using fir1 (a built-in MATLAB function that designs FIR filters through the window method). The script then converts the coefficients to signed 8-bit integers that are compatible with the FPGA hardware. These coefficients were applied to a simulated 1.2 kHz square wave input and the Total Harmonic Distortion (THD) of the filtered wave form is measured through the amplitude of the fundamental frequency and its odd harmonics. The applied cutoff frequency that produces the lowest THD value is represented by the smoothest possible output given 8 coefficients. Visualization of the optimal tap weights and the corresponding filtering they introduce is demonstrated in Figure 4.\n\n\n\nFigure 3: MATLAB Script Output Plot\n\n\n\n\n\nThe impacts from the 4x decimated sampling frequency were also visualized using the MATLAB script (Figure 4). The first plot shows and example 1 kHz input square wave that the barcode scanner would receive, the second shows the same square wave sampled at the original 48 kHz frequency, and the third plot shows the downsampled 12 kHz wave.\n\n\n\nFigure 4: MATLAB Script Output Plot"
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "This project would not have been successful without the tireless efforts of the following individuals:\nProf.¬†Spencer - Thank you for providing us with the tools, guidance, and support that made\nXavier Walter - Thank you for\nMicroPs Tutors - Neil Chulani, Kavi Dey, Troy Kauffman, and Vikram Krishna\nOur classmates - Thank you for supporting us throughout the entire semester, keeping us company during late night work sessions, and making MicroPs a truly memorable experience."
  },
  {
    "objectID": "acknowledgements.html#acknowledgements",
    "href": "acknowledgements.html#acknowledgements",
    "title": "Barcode Beats",
    "section": "",
    "text": "This project would not have been successful without the tireless efforts of the following individuals:\nProf.¬†Spencer - Thank you for providing us with the tools, guidance, and support that made\nXavier Walter - Thank you for\nMicroPs Tutors - Neil Chulani, Kavi Dey, Troy Kauffman, and Vikram Krishna\nOur classmates - Thank you for supporting us throughout the entire semester, keeping us company during late night work sessions, and making MicroPs a truly memorable experience."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "All MCU, FPGA, and MATLAB code related to this project can be found at the GitHub repository here.\n\n\n\nThe NetumScan USB 1D Barcode Scanner was selected as the barcode scanner of choice for this project due to its simple design and low cost. Using the barcode scanner beyond its intended purpose was a wild card design factor since there are no available PCB designs or product datasheets that could assist us in our redesign. Extensive research showed that barcode scanners should have a square wave signal that is the initial ‚Äúraw‚Äù interpretation of the barcode. With this in mind, the barcode scanner was disassembled and the PCB was probed extensively on the oscilloscope while scanning barcodes to find this desired signal. The pin referenced in the figure below was identified t be the source of the desired raw scanner signal that would be leveraged throughout the rest of the project.\n\n\n\nFigure 1: Internal Scanner Hardware close up with probe pointing to square wave source\n\n\nSince this pin was in close proximity to surrounding pins, the signal trace was further investigated until it was found to reach an empty surface mount resistor slot upon which a wire feeding to the FPGA was soldered.\nNext, the trigger switch was isolated in a similar fashion. The pin was found to idle high at 3.3 V, and when activated, dropped to 0 V. A wire was also soldered to this pin to ultimately feed to the MCU before reassmbling the device.\n\n\n\nThe schematic below showcases how the entire system interfaces with each other, the wired connections, and the analog components added for the audio amplifier.\n\n\n\nFigure 2: Electric Schematic for the Entire System\n\n\n\n\n\nThe block diagram below outlines the structure of the FPGA system design, including inputs, intermediate signals and modules, and outputs. The FPGA design consists of a synchronizer, a filter module, an internal clock and counter, and a SPI communicaiton module.\n\n\n\nFigure 3: FPGA Top Module Block Diagram\n\n\n\n\n\nThe project was given a budget of $50, and the Bill of Materials below show how that budget was allocated.\n\n\n\nItem\nLink / Source\nQuantity\nTotal Cost\n\n\n\n\nBarcode Scanner\nAmazon\n2\n$27.92\n\n\niCE40 UltraPlus 5K FPGA\nE155 Lab Kit\n1\n$0\n\n\nSTM32L432KC\nE155 Lab Kit\n1\n$0\n\n\nLM386 Audio Amplifier\nE155 Lab Kit\n1\n$0\n\n\n8 Œ© Speaker\nE155 Lab Kit\n1\n$0"
  },
  {
    "objectID": "documentation.html#project-documentation",
    "href": "documentation.html#project-documentation",
    "title": "Barcode Beats",
    "section": "",
    "text": "All MCU, FPGA, and MATLAB code related to this project can be found at the GitHub repository here.\n\n\n\nThe NetumScan USB 1D Barcode Scanner was selected as the barcode scanner of choice for this project due to its simple design and low cost. Using the barcode scanner beyond its intended purpose was a wild card design factor since there are no available PCB designs or product datasheets that could assist us in our redesign. Extensive research showed that barcode scanners should have a square wave signal that is the initial ‚Äúraw‚Äù interpretation of the barcode. With this in mind, the barcode scanner was disassembled and the PCB was probed extensively on the oscilloscope while scanning barcodes to find this desired signal. The pin referenced in the figure below was identified t be the source of the desired raw scanner signal that would be leveraged throughout the rest of the project.\n\n\n\nFigure 1: Internal Scanner Hardware close up with probe pointing to square wave source\n\n\nSince this pin was in close proximity to surrounding pins, the signal trace was further investigated until it was found to reach an empty surface mount resistor slot upon which a wire feeding to the FPGA was soldered.\nNext, the trigger switch was isolated in a similar fashion. The pin was found to idle high at 3.3 V, and when activated, dropped to 0 V. A wire was also soldered to this pin to ultimately feed to the MCU before reassmbling the device.\n\n\n\nThe schematic below showcases how the entire system interfaces with each other, the wired connections, and the analog components added for the audio amplifier.\n\n\n\nFigure 2: Electric Schematic for the Entire System\n\n\n\n\n\nThe block diagram below outlines the structure of the FPGA system design, including inputs, intermediate signals and modules, and outputs. The FPGA design consists of a synchronizer, a filter module, an internal clock and counter, and a SPI communicaiton module.\n\n\n\nFigure 3: FPGA Top Module Block Diagram\n\n\n\n\n\nThe project was given a budget of $50, and the Bill of Materials below show how that budget was allocated.\n\n\n\nItem\nLink / Source\nQuantity\nTotal Cost\n\n\n\n\nBarcode Scanner\nAmazon\n2\n$27.92\n\n\niCE40 UltraPlus 5K FPGA\nE155 Lab Kit\n1\n$0\n\n\nSTM32L432KC\nE155 Lab Kit\n1\n$0\n\n\nLM386 Audio Amplifier\nE155 Lab Kit\n1\n$0\n\n\n8 Œ© Speaker\nE155 Lab Kit\n1\n$0"
  },
  {
    "objectID": "bios.html",
    "href": "bios.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "I found E155: Microprocessor Design and Applications to be an incredibly rewarding and exciting course affirming my passion for the field. The project-based format placed me in the weeds of processor design programming, debugging, and implementation, allowing me to learn from the constant challenges. I learned so many valuable skills and feel this experience has bolstered my confidence in digital design and embedded systems. The final project, in particular, allowed me to see a fun idea through to a working result which is so cool. Through the labs and project, I faced many moments of not knowing if the designed system would work when challenging bugs arose and pushing past those moments developed a new level of grit and perseverance. Most of all I enjoyed my peers, the late nights and constant time spent underground foster a strong bond and spirit of collaboration. That exciting moment when you already overcame the bug your buddy is dealing with and can help them through it or the ability to ask someone to help you think through your road blocks affirmed that engineering is a collaborative pursuit and exemplified that together we can all go further.\n\n  LinkedIn    Github   Website \n\n\n\n\n\nMicroPs has been one of the most rewarding, challenging, and enriching experiences in my academic career. Despite my three years of engineering curriculum preceeding this course, I still doubted whether I could cultivate a unique project idea and see it through to completion. However, after this class and this project, I am instilled with greater confidence in my design and engineering capabilities. This class pushed me beyond my limits and allowed me to complete work similar to the projects that left me in awe on previous demo days. I feel that I can translate all of the skills I learned in FPGA design, MCU design, and work ethic to other personal projects and my future work.\n\n  LinkedIn    Github   Website"
  },
  {
    "objectID": "bios.html#meet-the-team",
    "href": "bios.html#meet-the-team",
    "title": "Barcode Beats",
    "section": "",
    "text": "I found E155: Microprocessor Design and Applications to be an incredibly rewarding and exciting course affirming my passion for the field. The project-based format placed me in the weeds of processor design programming, debugging, and implementation, allowing me to learn from the constant challenges. I learned so many valuable skills and feel this experience has bolstered my confidence in digital design and embedded systems. The final project, in particular, allowed me to see a fun idea through to a working result which is so cool. Through the labs and project, I faced many moments of not knowing if the designed system would work when challenging bugs arose and pushing past those moments developed a new level of grit and perseverance. Most of all I enjoyed my peers, the late nights and constant time spent underground foster a strong bond and spirit of collaboration. That exciting moment when you already overcame the bug your buddy is dealing with and can help them through it or the ability to ask someone to help you think through your road blocks affirmed that engineering is a collaborative pursuit and exemplified that together we can all go further.\n\n  LinkedIn    Github   Website \n\n\n\n\n\nMicroPs has been one of the most rewarding, challenging, and enriching experiences in my academic career. Despite my three years of engineering curriculum preceeding this course, I still doubted whether I could cultivate a unique project idea and see it through to completion. However, after this class and this project, I am instilled with greater confidence in my design and engineering capabilities. This class pushed me beyond my limits and allowed me to complete work similar to the projects that left me in awe on previous demo days. I feel that I can translate all of the skills I learned in FPGA design, MCU design, and work ethic to other personal projects and my future work.\n\n  LinkedIn    Github   Website"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Barcode Beats",
    "section": "",
    "text": "STM32L432KC reference manual and datasheet iCE40UP5K datasheet Barcode scanner datasheet"
  },
  {
    "objectID": "resources.html#project-resources",
    "href": "resources.html#project-resources",
    "title": "Barcode Beats",
    "section": "",
    "text": "STM32L432KC reference manual and datasheet iCE40UP5K datasheet Barcode scanner datasheet"
  }
]